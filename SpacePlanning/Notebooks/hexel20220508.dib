#!fsharp

// Coordinates and Host bool
type XYZ = {X : int ; Y : int ; Z : double ; H : bool}

// Convert invalid coordinates to valid hexel grid coordinates
let hxVldOg (og : XYZ) = 
    match (og.X % 2 = 0) with 
    | true -> { X = og.X ; Y = og.Y - (og.Y % 4) + 1 ; Z = og.Z ; H = true }
    | false -> { X = og.X ; Y = og.Y - (og.Y % 4) + 3 ; Z = og.Z ; H = true }

// Adjacent Hexel Origins XY
let hxAdjOg (og : XYZ) = 
    List.map2 (fun x y -> { X = og.X + x; Y = og.Y + y ; Z = og.Z ; H = true })
        [-2;-1;1;2;1;-1] [0;2;2;0;-2;-2]

// Incremental hexel (returns H false if not valid host)
let hxIncOg (og : XYZ) (oc : XYZ list) = 
    match og.H with 
    | true -> 
        let a = og |> hxAdjOg |> List.except oc |> List.tryHead
        match a with 
        | None -> {og with H = false}
        | Some a-> Some a |> Option.get
    | false -> og

let rec hxInOgs (og : XYZ list) (oc : XYZ list) = 
    match og with 
    | [] -> []
    | a :: b -> 
                let c = hxIncOg a oc
                let oc = c :: oc
                c :: hxInOgs b oc

let hxMlOgs (og : XYZ list) (oc : XYZ list) (ct : int) = 
    let rec hxMlOg1 (og : XYZ list) (oc : XYZ list) (ct : int) = 
        let op = oc
        let lg = List.length og
        let mx = (lg * (ct+2))
        match ((List.length oc) < mx) with 
        | true -> hxMlOg1 (hxInOgs  og oc) (oc@ (hxInOgs  og oc)) ct
        | false -> oc
    hxMlOg1 og  oc ct |> List.except oc

// Sample initial host origins 
let smplOr = {X=0;Y=0;Z=0;H=true} |> hxVldOg
let smplC1 = smplOr |> hxAdjOg
let smplC2 = smplOr :: smplC1
let smplOg = smplC1 |> List.take 3

//hxIncOg (smplC1 |>List.head) (smplC2)
//hxInOgs smplOg smplC2
//smplC2
//smplOg
//hxMlOgs smplOg smplC2 6
hxIncOg smplOr smplC2
