#!fsharp

// XY Infinite Grid
let x1 = Seq.initInfinite (fun x -> x * 2)
let y1 = Seq.initInfinite (fun y -> (y * 4) + 1)
let x2 = Seq.initInfinite (fun x -> (x * 2) + 1)
let y2 = Seq.initInfinite (fun y -> (y * 4) - 1) |> Seq.tail

// XY Limited Grid
type xy = {X:int;Y:int}
let xc = 3
let yc = 3
let xy1 = [for i in List.init xc (fun x -> x * 2) -> 
                [for j in List.init yc (fun y -> 
                    (y * 4) + 1) -> {X = i ; Y = j}] ]
let xy2 = [for i in List.init xc (fun x -> (x * 2) + 1) -> 
                [for j in List.init (yc + 1) (fun y -> 
                    (y * 4) - 1) 
                    |> List.tail -> {X = i ; Y = j}] ]
let a = [xy1;xy2]|>List.transpose |> List.concat

List.allPairs [0..2..(xc*2)] [1..4..(yc*4+1)]
List.allPairs [1..2..(xc*2+1)] [3..4..(yc*4+3)] 

#!fsharp

type xy = { X : int ; Y : int }

// Valid Hexel Origins XY
let hxVldOg (og : xy) = 
    match (og.X % 2 = 0) with 
    | true -> { X = og.X ; Y = og.Y - (og.Y % 4) + 1 }
    | false -> { X = og.X ; Y = og.Y - (og.Y % 4) + 3 }
    
// Adjacent Hexel Origins XY
let hxAdjOg (og : xy) = 
    List.map2 (fun x y -> { X = og.X + x; Y = og.Y + y }) 
        [-2;-1;1;2;1;-1] [0;2;2;0;-2;-2]

// Increment Hexel Origins XY
let hxIncOg (og : xy list) (oc : xy list) = 
    [for i in og -> 
            let ad1 = hxAdjOg i
            let xy1 = List.except (oc@og) ad1 |> List.head
            let oc = xy1 :: oc
            xy1]

// Cluster (Single) Hexel Origins XY
let hxClsOg (ct : int) (og : xy) (oc : xy list) = 

    let rec cl (c : int) (h : xy list) (o : xy list) (a : xy list) = 
        match h with 
        | [] -> []
        | x :: y when List.length a < c -> 
            cl c (List.except o (hxAdjOg x)) 
                (o @ [x] @ y) 
                    (a @ hxAdjOg x |> List.distinct)
        | _ -> List.take c a 
    
    cl ct (hxAdjOg og) oc [] |> List.distinct

// Clusters (Multiple) Hexel Origins XY
let hxClmOg (ct : int list) (hs : xy list) (oc : xy list) = 
    
    let hxCl01 (ct : int list) (og : xy list) (oc : xy list) =
        let og1 = List.map2 (fun x y -> [x] @ [y]) og (hxIncOg og oc)
        List.map2 (fun x y -> 
                match y with
                | [] -> []
                | y when (x < 3) -> [List.head y]
                | _ -> y) ct og1

    let rec hxCl02 (ct : int list) (hs : xy list) (oc : xy list) (ac : xy list list) = 
        let ct1 = List.map (fun x -> x + 1) ct
        match (List.concat ac |> List.length) < (List.sum ct1) with 
        | true -> hxCl02 ct1 
                    (List.map (fun x  -> List.last x) (hxCl01 ct1 hs oc)) 
                    (oc @ (ac |> List.concat)|> List.distinct) 
                    (List.map2 (fun x y -> (x @ y) ) ac (hxCl01 ct1 hs oc))
        | false -> List.map (fun x -> List.tail x) ac

    hxCl02 ct hs oc (List.map (fun x -> List.except [x] [x]) hs)


//hxAdjOg { X = 0; Y =1 }
//hxClsOg 5 {X=0;Y=1} (hxAdjOg {X = 2; Y =1})
//hxIncOg ((hxAdjOg {X=0;Y=1})|> List.take 3) ([{X= -3;Y=3};{X= -4;Y=1}])
hxClmOg [2;7;5;5;7] ([{X=0;Y=1};{X= -2;Y=1};{X= -1;Y=3};{X=1;Y=3};{X=2;Y=1}]) ([{X= -3;Y=3};{X= -4;Y=1}]) |>  List.map (fun x -> List.length x)
